# sql-transformer 호출 흐름 (메소드 시그니처 기준 / 상세)
> 생성 기준: src.zip(업로드된 src) 스캔 결과

## 1) 현재 흐름 요약 (큰 그림)
- **CLI 엔트리포인트**: `cli.AliasSqlGenerateCli.main(String[] args)`
- **실행 App**: `app.AliasSqlGenerateCliApp.main(String[] args)`
- **입력**: system/mode + (옵션) sqlsDir/callchain/mapping/out/result
- **로드 단계**
    - callchain 로드: `infra.callchain.ServiceSqlXrefLoader.loadCsv(Path)`
    - mapping 로드: `infra.mapping.ColumnMappingXlsxLoader.load(Path)` → `domain.mapping.ColumnMappingRegistry`
    - sql statement 로드: `infra.sql.SqlStatementRegistry.fromSqlsDir(Path)` (MyBatis Mapper XML 스캔)
- **변환 단계**
    - SQL 텍스트 resolve: `infra.text.CsvFirstSqlTextProvider.resolve(namespace, sqlId, csvSqlText)`
    - 변환: `domain.convert.AliasSqlGenerator.generate(mode, namespace, sqlId, sqlText, warningSink)`
        - select 변환(세그먼트 단위): `domain.convert.SqlSegmentTransformer.transformAllSelectSegments(...)`
        - DML 컬럼 주석/매핑: `domain.convert.SelectLineTransformer.annotateDml(...)` → `domain.convert.DmlAnnotator.annotateDml(...)`
    - (옵션) ASIS residue 검증: `domain.convert.AsisResidueValidator.validate(...)`
- **출력**
    - `.sql` 파일: `infra.output.FileSqlOutputWriter.write(outDir, serviceClass, namespace, sqlId, sqlText)` → `infra.output.AliasSqlFileWriter.write(...)`
    - 결과 엑셀: `infra.output.XlsxResultWriter.writeAll(...)`

## 2) 메소드 시그니처 기준 “촘촘한 호출 순서”
아래는 **실제 소스에 존재하는 메소드 시그니처**를 기준으로, 한 번의 실행에서 일반적으로 흘러가는 순서를 **위→아래**로 정리한 것입니다.
### 2.1 Entry → Args/Path
1. `cli.AliasSqlGenerateCli.main(String[] args)`
    - calls → `app.AliasSqlGenerateCliApp.main(String[] args)`
2. `app.AliasSqlGenerateCliApp.main(String[] args)`
    - calls → `cli.CliArgParser.parseArgs(String[] args)`
    - calls → `cli.CliPathResolver.resolveBaseDir()`
    - calls → `cli.CliPathResolver.resolveSqlsDir(Path baseDir, String system, Map<String,String> argv)`
    - (옵션) calls → `cli.CliPathResolver.resolvePath(Path baseDir, String raw)`

### 2.2 Components Wiring
3. `app.AliasSqlGenerateComponentsFactory.<init>(boolean pretty, boolean fallbackEnabled, Path sqlsDir)`
4. `app.AliasSqlGenerateComponentsFactory.createColumnMappingRegistry(Path mappingXlsx)`
    - calls → `infra.mapping.ColumnMappingXlsxLoader.load(Path xlsxPath)`
    - calls → `domain.mapping.ColumnMappingRegistry.of(List<ColumnMapping> mappings)` (정적 팩토리)
5. `app.AliasSqlGenerateComponentsFactory.loadCalls(Path callchain)`
    - calls → `infra.callchain.ServiceSqlXrefLoader.loadCsv(Path csvPath)`
6. `app.AliasSqlGenerateComponentsFactory.createSqlTextProvider(SqlStatementRegistry sqlRegistry, SqlTextResolutionWarnings warnings)`
    - calls → `infra.text.CsvFirstSqlTextProvider.<init>(SqlStatementRegistry, SqlTextResolutionWarnings)`
7. `app.AliasSqlGenerateComponentsFactory.createGenerator(ColumnMappingRegistry mappingRegistry, boolean enforceAsisResidue)`
    - calls → `domain.convert.AliasSqlGenerator.<init>(...)`
8. `app.AliasSqlGenerateComponentsFactory.createSqlOutputWriter()`
    - calls → `infra.output.FileSqlOutputWriter.<init>(AliasSqlFileWriter delegate)`
9. `app.AliasSqlGenerateComponentsFactory.createResultWriter(Path resultXlsx)`
    - calls → `infra.output.XlsxResultWriter.<init>(Path resultXlsx)`

### 2.3 SQL Statement (MyBatis Mapper XML) 로드
10. `infra.sql.SqlStatementRegistry.fromSqlsDir(Path sqlsDir)`
    - calls → `infra.sql.SqlsDirectoryScanner.scan(Path sqlsDir)`
    - per XML file calls → `infra.sql.MapperXmlLoader.loadXml(Path xmlPath)`
    - builds → `(namespace, sqlId) -> SqlStatement` 인덱스

### 2.4 Callchain 루프 1건 처리
11. (for each call) `infra.text.CsvFirstSqlTextProvider.resolve(String namespace, String sqlId, String csvSqlText)`
    - calls → `infra.sql.SqlStatementRegistry.get(String namespace, String sqlId)` (XML에서 SQL을 우선 조회)
    - returns → `domain.convert.SqlTextResolution` (sqlText + fallback 여부 + 출처 등)
12. `domain.convert.AliasSqlGenerator.generate(AliasSqlGenerator.Mode mode, String namespace, String sqlId, String sqlText, ConversionWarningSink warningSink)`
    - calls → `domain.convert.AliasSqlGeneratorEngine.generate(...)`

### 2.5 변환 파이프라인 (Engine 내부)
13. `domain.convert.AliasSqlGeneratorEngine.generate(AliasSqlGenerator.Mode mode, String namespace, String sqlId, String sqlText, ConversionWarningSink sink)`
    - (alias/table map) calls → `domain.convert.FromJoinAliasResolver.resolve(String sqlText)`
    - (select) calls → `domain.convert.SqlSegmentTransformer.transformAllSelectSegments(String sqlText, AliasSqlGenerator.Mode mode, Map<String,String> aliasTableMap, ConversionContext ctx, ConversionWarningSink sink)`
        - uses → `domain.convert.SelectLineTransformer.transformSelectBody(...)`
        - 내부 분해/경계 유지 → `domain.convert.SqlTopLevelSplitter.splitTopLevelComma(...)`
    - (DML annotate) calls → `domain.convert.SelectLineTransformer.annotateDml(String sqlText, AliasSqlGenerator.Mode mode, Map<String,String> aliasTableMap, ConversionContext ctx, ConversionWarningSink sink)`
        - calls → `domain.convert.DmlAnnotator.annotateDml(...)`

### 2.6 (옵션) ASIS residue 검증
14. `domain.convert.AsisResidueValidator.validate(String sqlText, ColumnMappingRegistry registry, ConversionContext ctx, ConversionWarningSink sink)`
    - 목적: ASIS 테이블/컬럼이 변환 결과에 잔존하는지 탐지(옵션에 따라 fail-fast 가능)

### 2.7 출력
15. `.sql` 파일 출력
    - `infra.output.FileSqlOutputWriter.write(Path outDir, String serviceClass, String namespace, String sqlId, String sqlText)`
        - calls → `infra.output.AliasSqlFileWriter.write(Path targetDir, String serviceClass, String namespace, String sqlId, String sqlText)`
16. 결과 엑셀 출력
    - `infra.output.XlsxResultWriter.writeAll(List<ResultRow> rows)`
        - uses → `infra.result.ResultWriter.open()` / `write(ResultRow)` / `close()`

## 3) 핵심 메소드 선언 위치(파일/라인)
|구간|파일|라인|선언(원문)
|---|---:|---:|---|
|Entrypoint|`src/main/java/cli/AliasSqlGenerateCli.java`|18|`public static void main(String[] args) throws Exception {`|
|Main app|`src/main/java/app/AliasSqlGenerateCliApp.java`|55|`public static void main(String[] args) {`|
|Args parse|`src/main/java/cli/CliArgParser.java`|97|`public static Map<String, String> parseArgs(String[] args) {`|
|Base dir resolve|`src/main/java/cli/CliPathResolver.java`|22|`public static Path resolveBaseDir() {`|
|SQLs dir resolve|`src/main/java/cli/CliPathResolver.java`|55|`public static Path resolveSqlsDir(Path baseDir, String system, Map<String, String> argv) {`|
|Generic path resolve|`src/main/java/cli/CliPathResolver.java`|77|`public static Path resolvePath(Path baseDir, String input) {`|
|Factory: createSqlTextProvider|`src/main/java/app/AliasSqlGenerateComponentsFactory.java`|37|`SqlTextProvider createSqlTextProvider(SqlStatementRegistry registry, boolean enableFallback) {`|
|Factory: createColumnMappingRegistry|`src/main/java/app/AliasSqlGenerateComponentsFactory.java`|42|`ColumnMappingRegistry createColumnMappingRegistry(Path mappingXlsxPath) {`|
|Factory: loadCalls|`src/main/java/app/AliasSqlGenerateComponentsFactory.java`|46|`List<ServiceSqlCall> loadCalls(Path callchainCsvPath) {`|
|Factory: createSqlOutputWriter|`src/main/java/app/AliasSqlGenerateComponentsFactory.java`|55|`SqlOutputWriter createSqlOutputWriter(boolean enable) {`|
|Factory: createResultWriter|`src/main/java/app/AliasSqlGenerateComponentsFactory.java`|61|`ResultWriter createResultWriter(boolean enable) {`|
|Factory: createGenerator|`src/main/java/app/AliasSqlGenerateComponentsFactory.java`|51|`AliasSqlGenerator createGenerator(ColumnMappingRegistry columnMappingRegistry) {`|
|Callchain loader: loadCsv|`src/main/java/infra/callchain/ServiceSqlXrefLoader.java`| |(탐지 실패/시그니처가 여러 줄일 수 있음)|
|Mapping loader: load|`src/main/java/infra/mapping/ColumnMappingXlsxLoader.java`|20|`public Map<String, ColumnMapping> load(String resourcePath) {`|
|SQL registry: fromSqlsDir|`src/main/java/infra/sql/SqlStatementRegistry.java`| |(탐지 실패/시그니처가 여러 줄일 수 있음)|
|SQL scan: scan|`src/main/java/infra/sql/SqlsDirectoryScanner.java`| |(탐지 실패/시그니처가 여러 줄일 수 있음)|
|Mapper XML loader: loadXml|`src/main/java/infra/sql/MapperXmlLoader.java`| |(탐지 실패/시그니처가 여러 줄일 수 있음)|
|SQL text provider: resolve|`src/main/java/infra/text/CsvFirstSqlTextProvider.java`|21|`public SqlTextResolution resolve(String namespace, String sqlId, String csvSqlText) {`|
|Generator: generate|`src/main/java/domain/convert/AliasSqlGenerator.java`|33|`public String generate(String sqlText, Mode mode) {`|
|Engine: generate|`src/main/java/domain/convert/AliasSqlGeneratorEngine.java`|44|`String generate(String sqlText, Mode mode) {`|
|Segment transformer: transformAllSelectSegments|`src/main/java/domain/convert/SqlSegmentTransformer.java`|24|`String transformAllSelectSegments(String sql, Mode mode, Map<String, String> paramRenameMap) {`|
|Select transformer: transformSelectBody|`src/main/java/domain/convert/SelectLineTransformer.java`|20|`public String transformSelectBody(String selectBody, ...`|
|Select transformer: annotateDml|`src/main/java/domain/convert/SelectLineTransformer.java`|49|`public String annotateDml(String sql, Map<String, String> aliasTableMap) {`|
|DML annotator: annotateDml|`src/main/java/domain/convert/DmlAnnotator.java`|31|`String annotateDml(String sql, Map<String, String> aliasTableMap) {`|
|Residue validator: validate|`src/main/java/domain/convert/AsisResidueValidator.java`|39|`public void validate(String convertedSql, ...`|
|SQL output writer: write|`src/main/java/infra/output/FileSqlOutputWriter.java`|25|`public void write(Path outDir, String serviceClass, String namespace, String sqlId, String sqlText) {`|
|File writer: write|`src/main/java/infra/output/AliasSqlFileWriter.java`|20|`public Path write(Path outDir, String serviceClass, String namespace, String sqlId, String sqlText) {`|
|Result writer: open|`src/main/java/domain/output/ResultWriter.java`| |(탐지 실패/시그니처가 여러 줄일 수 있음)|
|Result writer impl: writeAll|`src/main/java/infra/output/XlsxResultWriter.java`| |(탐지 실패/시그니처가 여러 줄일 수 있음)|

---
### 참고
- 위 호출순서는 **소스 코드 상의 호출 관계**를 기준으로 정리했으며, 옵션(`--noResult`, `--noFallback`, `--mode`)에 따라 일부 단계는 생략됩니다.
